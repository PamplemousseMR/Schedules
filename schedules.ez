\User declarations :

#include <utility>
#include <functional>

#include "Src/Teacher.hpp"
#include "Src/Room.hpp"
#include "Src/Subject.hpp"
#include "Src/Class.hpp"
#include "Src/Lesson.hpp"
#include "Src/Utility.hpp"

/* ---------------------------------------------------------------------------------
										Schedules
--------------------------------------------------------------------------------- */

static const unsigned short WEEK_BY_SEMESTER = 14;
static const unsigned short MAX_HOUR_PER_WEEK = 30;
static const unsigned short MAX_HOUR_PER_DAY = 6; 

typedef std::map<Lesson::LESSON_SLOT, std::vector<Lesson>> Day;
typedef std::map<Lesson::LESSON_DAY, Day> Week;
typedef std::map<int, Week> Schedules; 

static const std::vector< std::tuple< Subject::SUBJECT_MODALITY, const Subject&, const Class& > > s_MAP;

static const unsigned short s_STRONG_CONSTRAINT = 2;
static const unsigned short s_WEAK_CONSTRAINT = 1;

\end

/* ------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------ */

\User functions:
\end

/* ------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------ */

\User CUDA:
\end

/* ------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------ */

\Before everything else function:

	auto& list = const_cast< std::vector< std::tuple< Subject::SUBJECT_MODALITY, const Subject&, const Class& > >& >(s_MAP);

	for(unsigned i = 0; i < Subject::s_subjects.size(); ++i) 
	{ 
		const Subject& subject = Subject::s_subjects[i]; 
		for(int modality = 0 ; modality < Subject::MODALITY_SIZE ; ++modality)
		{
			Subject::SUBJECT_MODALITY mod = static_cast<Subject::SUBJECT_MODALITY>(modality);
			float number = subject.m_modality.at(mod)/Lesson::SLOT_INTERVAL;
			switch(subject.m_semester)
			{
				case Subject::S1 :
				case Subject::S2 :
					switch(mod)
					{
						case Subject::CM : 
						case Subject::CI : 
          					for(float j = 0.f; j < number; j++) 
	        				{ 
	            				list.emplace_back(mod, subject, Class::s_classes[0]);
	        				}  
						break;
						case Subject::TD : 
							for(int spe = 0; spe < Class::s_specialityPerYeer; ++spe)
							{
								for(float j = 0.f; j < number; j++) 
		        				{ 
		            				list.emplace_back(mod, subject, Class::s_classes[2+spe]); 
		        				}  
		        			}
						break;
						case Subject::TP : 
							for(int tp = 0; tp < Class::s_L0Count; ++tp)
							{
								for(float j = 0.f; j < number; j++) 
			        			{ 
			            			list.emplace_back(mod, subject, Class::s_classes[10+tp]);
			        			}  
		        			}
						break;
						case Subject::MODALITY_SIZE :
						break;
					}
					break;
				case Subject::S3 :
				case Subject::S4 :
					switch(mod)
					{
						case Subject::CM : 
						case Subject::CI :
							if(subject.m_speciality == Subject::COMMUN) 
							{
								for(float j = 0.f; j < number; j++) 
			        			{ 
			            			list.emplace_back(mod, subject, Class::s_classes[1]);
			        			}  
							}
	        				else
	        				{
								for(float j = 0.f; j < number; j++) 
			        			{ 
			            			list.emplace_back(mod, subject, Class::s_classes[6+subject.m_speciality]);
			        			}  
							}
						break;
						case Subject::TD : 
							if(subject.m_speciality == Subject::COMMUN) 
							{
								for(int spe = 0; spe < Class::s_specialityPerYeer; ++spe)
								{
									for(float j = 0.f; j < number; j++) 
		        					{ 
		            					list.emplace_back(mod, subject, Class::s_classes[6+spe]); 
		        					}  
		        				}
		        			}
		        			else
		        			{
								for(float j = 0.f; j < number; j++) 
			        			{ 
			            			list.emplace_back(mod, subject, Class::s_classes[6+subject.m_speciality]);
			        			}  
	        				}
						break;
						case Subject::TP : 
							if(subject.m_speciality == Subject::COMMUN) 
							{
								for(int tp = 0; tp < Class::s_L1Count; ++tp)
								{
									for(float j = 0.f; j < number; j++) 
									{ 
										list.emplace_back(mod, subject, Class::s_classes[18+tp]);
									}  
			        			}
		        			}
		        			else
		        			{
								for(float j = 0.f; j < number; j++) 
			        			{ 
			            			list.emplace_back(mod, subject, Class::s_classes[18+subject.m_speciality*2]);
			        			}  
								for(float j = 0.f; j < number; j++) 
			        			{ 
			            			list.emplace_back(mod, subject, Class::s_classes[18+subject.m_speciality*2+1]);
			        			}  
		        			}	
						break;
						case Subject::MODALITY_SIZE :
						break;
					}
				break;
			} 
		}
	} 
	list = shuffleVector(list);

\end

/* ------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------ */

\After everything else function:
\end

/* ------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------ */

\At the beginning of each generation function:
\endstatic_

/* ------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------ */

\At the end of each generation function:
\end

/* ------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------ */

\At each generation before reduce function:
\end

/* ------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------ */

\User classes :
	GenomeClass { 
		int* m_schedules;	// This is a HACK, it will be changed to void*.
	}
\end

/* ------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------ */

\GenomeClass::display:
\end

/* ------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------ */

\GenomeClass::initialiser:

	Schedules* schedules = new Schedules();

	for(const auto& tuple : shuffleVector(s_MAP))
	{
		Subject::SUBJECT_MODALITY mod = std::get<0>(tuple);
		const Subject& sub = std::get<1>(tuple);
		const Class& classes = std::get<2>(tuple);
		int randWeek = random(0, WEEK_BY_SEMESTER);
		if(sub.m_semester == Subject::S2 || sub.m_semester == Subject::S4)
		{
			randWeek += WEEK_BY_SEMESTER;
		}
		int randDay = random(0, Lesson::DAY_SIZE);
		int randSlot = random(0, Lesson::SLOT_SIZE);

		(*schedules)[randWeek][static_cast<Lesson::LESSON_DAY>(randDay)][static_cast<Lesson::LESSON_SLOT>(randSlot)].emplace_back(sub, randTeacher(sub), randRoom(sub, mod), classes, mod);
	}

	//static const std::vector< std::tuple< Subject::SUBJECT_MODALITY, Subject, std::initializer_list<Class> > > s_MAP;
	/*for(unsigned short _week = 0; _week < WEEK_BY_SEMESTER*2; ++_week)
	{
		for(unsigned short _day = 0; _day < Lesson::DAY_SIZE; ++_day)
		{
			for(unsigned short _slot = 0; _slot < Lesson::SLOT_SIZE; ++_slot)
			{
				std::cout << _week << " " << _day << " " << _slot << "\n\t";
				auto vec = (*schedules)[_week][static_cast<Lesson::LESSON_DAY>(_day)][static_cast<Lesson::LESSON_SLOT>(_slot)];
				for(const Lesson& lesson : vec)
				{
					std::cout << lesson << std::endl; 
				}
			}
		}
	}*/

	Genome.m_schedules = (void*)schedules;

\end

/* ------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------ */

\GenomeClass::crossover:
\end

/* ------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------ */

\GenomeClass::mutator:
  	return 1;
\end

/* ------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------ */

\GenomeClass::evaluator:
	return 1;
\end

/* ------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------ */

\User Makefile options:
	CPPFLAGS += -std=c++11 -o3
\end

/* ------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------ */

\Default run parameters :         // Please let the parameters appear in this order
Number of generations : 300       // NB_GEN
Time limit: 0                     // In seconds, 0 to deactivate
Population size : 65536           // POP_SIZE
Offspring size : 100%             // 40% 
Mutation probability : 1          // MUT_PROB
Crossover probability : 1         // XOVER_PROB
Evaluator goal : minimise         // Maximise
Selection operator: Tournament 2 
Surviving parents: 100%           // percentage or absolute
Surviving offspring: 100%
Reduce parents operator: Tournament 2
Reduce offspring operator: Tournament 2
Final reduce operator: Tournament 3

Elitism: Weak                     // Weak or Strong
Elite: 1
Print stats: true                 // Default: 1
Generate csv stats file:false
Generate gnuplot script:false
Generate R script:false
Plot stats:true                   // Default: 0

Remote island model: true
IP file: ipexplorer.txt           // File containing all the remote island's IP
Server port : 2929
Migration probability: 0.15       // 0.15 or 0.5

Save population: false
Start from file:false
\end
