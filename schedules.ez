\User declarations :

#include <vector>
#include <map>
#include <cstdarg>

#include "Teacher.h"
#include "Room.h"
#include "Subject.h"
#include "Class.h"

/* ---------------------------------------------------------------------------------
										Schedules
--------------------------------------------------------------------------------- */

/* ---------------------------
		Day
--------------------------- */

enum DAY
{
	MONDAY,
	TUESDAY,
	WEDNESDAY,
	THURSDAY,
	FRIDAY
};

/* ---------------------------
		Time slots
--------------------------- */

enum SLOT
{
	SLOT_0,
	SLOT_1,
	SLOT_2,
	SLOT_3
};

/* ---------------------------
		Lesson
--------------------------- */

class Lesson
{

public:

	Lesson(const std::string& _ueName, const Teacher& _teacher, const Room& _room,
									std::initializer_list<Class> _classList)
		: 	m_UEname(_ueName),
			m_teacher(_teacher),
			m_room(_room),
			m_class(_classList.begin(), _classList.end())
	{
	}

private:

	const std::string m_UEname;

	const Teacher& m_teacher;

	const Room& m_room;
	
	const std::vector<Class> m_class;

};

/* ---------------------------
		Schedules
--------------------------- */

typedef std::map<SLOT, std::vector<Lesson>> Day;
typedef std::map<DAY, Day> Week;
typedef std::map<int, Week> Schedules; 

\end

\User functions:
\end

\User CUDA:
\end

\Before everything else function:
	std::cout << "Teacher list =>" << std::endl;
	for(Teacher _t : Teacher::s_teachers)
	{
		_t.display();
	}
	std::cout << "Room list =>" << std::endl;
	for(Room _r : Room::s_rooms)
	{
		_r.display();
	}
	std::cout << "Class list =>" << std::endl;
	for(Class _c : Class::s_class)
	{
		_c.display();
	}
	std::cout << "Subject list =>" << std::endl;
	for(Subject _s : Subject::s_subjects)
	{
		_s.display();
	}
\end

\After everything else function:
\end

\At the beginning of each generation function:
\end

\At the end of each generation function:
\end

\At each generation before reduce function:
\end

\User classes :
	GenomeClass { 
		int* m_schedules;	// This is a HACK
	}
\end

\GenomeClass::display:
\end

\GenomeClass::initialiser:
\end

\GenomeClass::crossover:
\end

\GenomeClass::mutator:
  	return 1;
\end

\GenomeClass::evaluator:
	return 1;
\end

\User Makefile options:
	CPPFLAGS += -std=c++11
\end

\Default run parameters :         // Please let the parameters appear in this order
Number of generations : 300       // NB_GEN
Time limit: 0                     // In seconds, 0 to deactivate
Population size : 65536           // POP_SIZE
Offspring size : 100%             // 40% 
Mutation probability : 1          // MUT_PROB
Crossover probability : 1         // XOVER_PROB
Evaluator goal : minimise         // Maximise
Selection operator: Tournament 2 
Surviving parents: 100%           // percentage or absolute
Surviving offspring: 100%
Reduce parents operator: Tournament 2
Reduce offspring operator: Tournament 2
Final reduce operator: Tournament 3

Elitism: Weak                     // Weak or Strong
Elite: 1
Print stats: true                 // Default: 1
Generate csv stats file:false
Generate gnuplot script:false
Generate R script:false
Plot stats:true                   // Default: 0

Remote island model: true
IP file: ipexplorer.txt           // File containing all the remote island's IP
Server port : 2929
Migration probability: 0.15       // 0.15 or 0.5

Save population: false
Start from file:false
\end
