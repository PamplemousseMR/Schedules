\User declarations :

#include <vector>
#include <map>
#include <cstdarg>
#include <algorithm>

#include "Teacher.h"
#include "Room.h"
#include "Subject.h"
#include "Class.h"
#include "Lesson.h"

/* ---------------------------------------------------------------------------------
										Schedules
--------------------------------------------------------------------------------- */

static const unsigned short WEEK_BY_SEMESTER = 14;
static const unsigned short MAX_HOUR_PER_WEEK = 30;
static const unsigned short MAX_HOUR_PER_DAY = 6; 

typedef std::map<Lesson::LESSON_SLOT, std::vector<Lesson>> Day;
typedef std::map<Lesson::LESSON_DAY, Day> Week;
typedef std::map<int, Week> Schedules; 

typedef struct Tuple_t
{
	int m_week;
	const Room& m_room;
	Lesson::LESSON_DAY m_day;
	Lesson::LESSON_SLOT m_slot;
} Tuple;

\end

/* ------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------ */

\User functions:

bool teacherBusy(const Day& _day, const Lesson::LESSON_SLOT _slot, const Teacher& _teacher)
{
	for(const Lesson& lesson : _day.at(_slot))
	{
		if(&lesson.m_teacher == &_teacher)
		{
			return true;
		}
	}
	return false;
}

bool roomBusy(const Day& _day, const Lesson::LESSON_SLOT _slot, const Room& _room)
{
	for(const Lesson& lesson : _day.at(_slot))
	{
		if(&lesson.m_room == &_room)
		{
			return true;
		}
	}
	return false;
}

bool classBusy(const Day& _day, const Lesson::LESSON_SLOT _slot, const Class& _class)
{
	for(const Lesson& lesson : _day.at(_slot))
	{
		for(const Class& t_class : lesson.m_class)
		{
			if(&t_class == &_class)
			{
				return true;
			}
		}
	}
	return false;
}

template<typename T>
std::vector<T> shuffleVector(const std::vector<T>& _vec)
{
	std::vector<size_t> value;
	for(size_t i=0 ; i<_vec.size() ; ++i)	
	{
		value.push_back(i);
	}

	std::vector<T> result;
	while(!value.empty())
	{
		unsigned rand = random(0, value.size());
		result.push_back(_vec[value[rand]]);
		value.erase(value.begin()+rand);
	}

	return result;
}

\end

/* ------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------ */

\User CUDA:
\end

/* ------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------ */

\Before everything else function:
	std::cout << "Teacher list =>" << std::endl;
	for(Teacher _t : Teacher::s_teachers)
	{
		_t.display();
	}
	std::cout << "Room list =>" << std::endl;
	for(Room _r : Room::s_rooms)
	{
		_r.display();
	}
	std::cout << "Class list =>" << std::endl;
	for(Class _c : Class::s_class)
	{
		_c.display();
	}
	std::cout << "Subject list =>" << std::endl;
	for(Subject _s : Subject::s_subjects)
	{
		_s.display();
	}
\end

/* ------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------ */

\After everything else function:
\end

/* ------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------ */

\At the beginning of each generation function:
\end

/* ------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------ */

\At the end of each generation function:
\end

/* ------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------ */

\At each generation before reduce function:
\end

/* ------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------ */

\User classes :
	GenomeClass { 
		int* m_schedules;	// This is a HACK, it will be changed to void*.
	}
\end

/* ------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------ */

\GenomeClass::display:
\end

/* ------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------ */

\GenomeClass::initialiser:

	Schedules* schedules = new Schedules();

	std::vector<Subject> sub_shuffle;
	for(unsigned i = 0; i < Subject::s_subjects.size(); ++i)
	{
		const Subject& subject = Subject::s_subjects.at(i);
		float number = subject.m_modality.at(Subject::CM)/Lesson::SLOT_INTERVAL; 
		for(float j = 0.; j < number; j++)
		{
			sub_shuffle.push_back(subject);
		}
	}

  	sub_shuffle = shuffleVector(sub_shuffle);

  	std::vector<Tuple> tup_shuffle_first;
  	std::vector<Tuple> tup_shuffle_second;
  	for(unsigned i = Room::s_amphiOffset; i < Room::s_amphiCount; ++i)
  	{
  		for(unsigned short _week = 0; _week < WEEK_BY_SEMESTER; ++_week)
		{
			for(unsigned short _day = 0; _day < Lesson::DAY_SIZE; ++_day)
			{
				for(unsigned short _slot = 0; _slot < Lesson::SLOT_SIZE; ++_slot)
				{
					{
						Tuple tuple {_week, Room::s_rooms[i], static_cast<Lesson::LESSON_DAY>(_day), static_cast<Lesson::LESSON_SLOT>(_slot)};
						tup_shuffle_first.push_back(tuple);
					}
					{
						Tuple tuple {_week+WEEK_BY_SEMESTER, Room::s_rooms[i], static_cast<Lesson::LESSON_DAY>(_day), static_cast<Lesson::LESSON_SLOT>(_slot)};
						tup_shuffle_second.push_back(tuple);
					}
				}
			}
		}
  	} 

  	tup_shuffle_first = shuffleVector(tup_shuffle_first);
  	tup_shuffle_second = shuffleVector(tup_shuffle_second);

  	//TODO
  	const Teacher& t = Teacher::s_teachers[0];

  	for(const Subject& sub : sub_shuffle)
  	{
  		std::vector<Tuple>* tup_suffle;
  		std::initializer_list<Class> classes;
  		switch (sub.m_semester) {
  			case(Subject::S1) : 
  				tup_suffle = &tup_shuffle_first;
  				classes = {Class::s_class[0], Class::s_class[1], Class::s_class[2], Class::s_class[3], Class::s_class[4], Class::s_class[5], Class::s_class[6], Class::s_class[7]};
  				break;
  			case(Subject::S2) : 
  				tup_suffle = &tup_shuffle_second;
  				classes = {Class::s_class[0], Class::s_class[1], Class::s_class[2], Class::s_class[3], Class::s_class[4], Class::s_class[5], Class::s_class[6], Class::s_class[7]};
  				break;
  			case(Subject::S3) : 
  				tup_suffle = &tup_shuffle_first;	
  				classes = {Class::s_class[8], Class::s_class[9], Class::s_class[10], Class::s_class[11], Class::s_class[12], Class::s_class[13], Class::s_class[14], Class::s_class[15]};
  				break;  
  			case(Subject::S4) : 
  				tup_suffle = &tup_shuffle_second;
  				classes = {Class::s_class[8], Class::s_class[9], Class::s_class[10], Class::s_class[11], Class::s_class[12], Class::s_class[13], Class::s_class[14], Class::s_class[15]};
  				break;
  		}
  		const Tuple& tuple = (*tup_suffle).back();
  		(*tup_suffle).pop_back();
  		(*schedules)[tuple.m_week][tuple.m_day][tuple.m_slot].emplace_back(Lesson(sub.m_name, t, tuple.m_room, classes));
  	}


	// TODO
	for(unsigned short _week = 0; _week < WEEK_BY_SEMESTER*2; ++_week)
	{
		for(unsigned short _day = 0; _day < Lesson::DAY_SIZE; ++_day)
		{
			for(unsigned short _slot = 0; _slot < Lesson::SLOT_SIZE; ++_slot)
			{
				std::cout << _week << " " << _day << " " << _slot << "\n\t";
				auto vec = (*schedules)[_week][static_cast<Lesson::LESSON_DAY>(_day)][static_cast<Lesson::LESSON_SLOT>(_slot)];
				for(const Lesson& lesson : vec)
				{
					std::cout << "{" << lesson.m_UEname << " " << &lesson.m_room << "} "; 
				}
				std::cout << std::endl;
			}
		}
	}

	exit(0);
	Genome.m_schedules = (void*)schedules;
\end

/* ------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------ */

\GenomeClass::crossover:
\end

/* ------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------ */

\GenomeClass::mutator:
  	return 1;
\end

/* ------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------ */

\GenomeClass::evaluator:
	return 1;
\end

/* ------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------ */

\User Makefile options:
	CPPFLAGS += -std=c++11
\end

/* ------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------ */

\Default run parameters :         // Please let the parameters appear in this order
Number of generations : 300       // NB_GEN
Time limit: 0                     // In seconds, 0 to deactivate
Population size : 65536           // POP_SIZE
Offspring size : 100%             // 40% 
Mutation probability : 1          // MUT_PROB
Crossover probability : 1         // XOVER_PROB
Evaluator goal : minimise         // Maximise
Selection operator: Tournament 2 
Surviving parents: 100%           // percentage or absolute
Surviving offspring: 100%
Reduce parents operator: Tournament 2
Reduce offspring operator: Tournament 2
Final reduce operator: Tournament 3

Elitism: Weak                     // Weak or Strong
Elite: 1
Print stats: true                 // Default: 1
Generate csv stats file:false
Generate gnuplot script:false
Generate R script:false
Plot stats:true                   // Default: 0

Remote island model: true
IP file: ipexplorer.txt           // File containing all the remote island's IP
Server port : 2929
Migration probability: 0.15       // 0.15 or 0.5

Save population: false
Start from file:false
\end
