\User declarations :

#include <utility>
#include <functional>

#include "Teacher.h"
#include "Room.h"
#include "Subject.h"
#include "Class.h"
#include "Lesson.h"

/* ---------------------------------------------------------------------------------
										Schedules
--------------------------------------------------------------------------------- */

static const unsigned short WEEK_BY_SEMESTER = 14;
static const unsigned short MAX_HOUR_PER_WEEK = 30;
static const unsigned short MAX_HOUR_PER_DAY = 6; 

typedef std::map<Lesson::LESSON_SLOT, std::vector<Lesson>> Day;
typedef std::map<Lesson::LESSON_DAY, Day> Week;
typedef std::map<int, Week> Schedules; 

static const std::vector< std::tuple< Subject::SUBJECT_MODALITY, const Subject&, std::initializer_list<Class> > > s_MAP;

\end

/* ------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------ */

\User functions:

template<typename T>
std::vector<T> shuffleVector(const std::vector<T>& _vec)
{
	std::vector<size_t> value;
	for(size_t i=0 ; i<_vec.size() ; ++i)	
	{
		value.push_back(i);
	}

	std::vector<T> result;
	while(!value.empty())
	{
		unsigned rand = random(0, value.size());
		result.push_back(_vec[value[rand]]);
		value.erase(value.begin()+rand);
	}

	return result;
}

const Teacher& randTeacher(const Subject& _subject)
{
	int min = 0, max = Teacher::s_teachers.size();
	switch (_subject.m_type){
		case Subject::MATHS :
			max = 3;
		break;
		case Subject::PHYSICS :
			min = 3;
			max = 7;
		break;
		case Subject::COMPUTER_SCIENCE :
			min = 7;
			max = 11;
		break;
		case Subject::CHEMISTRY :
			min = 11;
			max = 15;
		break;
		case Subject::ENGLISH :
			min = 15;
			max = 19;
		break;
		case Subject::FRENCH :
			min = 19;
		break;
		case Subject::UNDEFINED :
		break;
	}
	return Teacher::s_teachers[random(min, max)];
}

const Room& randRoom(const Subject& _subject, Subject::SUBJECT_MODALITY _subMod)
{
	int min = 0, max = Room::s_rooms.size();
	switch(_subMod) 
	{
		case Subject::TP :
			switch(_subject.m_type)
			{
				case Subject::COMPUTER_SCIENCE :
					min = 14;
					max = 16;
				break;
				case Subject::PHYSICS :
				case Subject::CHEMISTRY :
					min = 16;
					max = 18;
				break;
				case Subject::ENGLISH :
				case Subject::FRENCH :
					min = 7;
					max = 14;
				break;
				case Subject::MATHS :
				case Subject::UNDEFINED :
				break;
			}
		break;
		case Subject::TD :
			max = 7;
		break;
		case Subject::CI :
		case Subject::CM :
			if(_subject.m_speciality == Subject::COMMUN)
			{
				max = 2;
			}
			else
			{
				max = 7;
			}
		break;
		case Subject::MODALITY_SIZE :
		break;
	}
	return Room::s_rooms[random(min, max)];
}

\end

/* ------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------ */

\User CUDA:
\end

/* ------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------ */

\Before everything else function:

	auto& list = const_cast< std::vector< std::tuple< Subject::SUBJECT_MODALITY, const Subject&, std::initializer_list<Class> > >& >(s_MAP);

	for(unsigned i = 0; i < Subject::s_subjects.size(); ++i) 
	{ 
		const Subject& subject = Subject::s_subjects.at(i); 
		//std::cout << "init ---------------------- : " << &subject << std::endl;
		for(int modality = 0 ; modality < Subject::MODALITY_SIZE ; ++modality)
		{
			Subject::SUBJECT_MODALITY mod = static_cast<Subject::SUBJECT_MODALITY>(modality);
			float number = subject.m_modality.at(mod)/Lesson::SLOT_INTERVAL; 
			std::initializer_list<Class> classes; 
			switch(subject.m_semester)
			{
				case Subject::S1 :
				case Subject::S2 :
					switch(mod)
					{
						case Subject::CM : 
						case Subject::CI : 
          					classes = {Class::s_class[0], Class::s_class[1], Class::s_class[2], Class::s_class[3], Class::s_class[4], Class::s_class[5], Class::s_class[6], Class::s_class[7]};
	        				for(float j = 0.f; j < number; j++) 
	        				{ 
	        					//std::cout << "init 2 : " << &subject << std::endl;
	            				list.emplace_back(std::make_tuple(mod, std::ref(subject), classes)); 
	            				//std::cout << "init 3 : " << &list[list.size()-1] << std::endl;
	        				}  
						break;
						case Subject::TD : 
							for(int spe = 0; spe < Class::s_specialityPerYeer; ++spe)
							{
								classes = {Class::s_class[Class::s_L0Offset+spe*2], Class::s_class[Class::s_L0Offset+spe*2+1]};
								for(float j = 0.f; j < number; j++) 
		        				{ 
		        					//std::cout << "init 2 : " << &subject << std::endl;
		            				list.emplace_back(std::make_tuple(mod, std::ref(subject), classes)); 
		            				//std::cout << "init 3 : " << &list[list.size()-1] << std::endl;
		        				}  
		        			}
						break;
						case Subject::TP : 
							for(int tp = 0; tp < Class::s_L0Count; ++tp)
							{
								classes = {Class::s_class[Class::s_L0Offset+tp]};
								for(float j = 0.f; j < number; j++) 
			        			{ 
			        				//std::cout << "init 2 : " << &subject << std::endl;
			            			list.emplace_back(std::make_tuple(mod, std::ref(subject), classes));
									//std::cout << "init 3 : " << &list[list.size()-1] << std::endl;
			        			}  
		        			}
						break;
						case Subject::MODALITY_SIZE :
						break;
					}
					break;
				case Subject::S3 :
				case Subject::S4 :
					switch(mod)
					{
						case Subject::CM : 
						case Subject::CI :
							if(subject.m_speciality == Subject::COMMUN) 
							{
								classes = {Class::s_class[8], Class::s_class[9], Class::s_class[10], Class::s_class[11], Class::s_class[12], Class::s_class[13], Class::s_class[14], Class::s_class[15]};
	        				}
	        				else
	        				{
	        					classes = {Class::s_class[Class::s_L1Offset+subject.m_speciality*2], Class::s_class[Class::s_L1Offset+subject.m_speciality*2+1]};
	        				}
	        				for(float j = 0.f; j < number; j++) 
	        				{	 
	        					//std::cout << "init 2 : " << &subject << std::endl;
	            				list.emplace_back(std::make_tuple(mod, std::ref(subject), classes)); 
	            				//std::cout << "init 3 : " << &list[list.size()-1] << std::endl;
	        				}
						break;
						case Subject::TD : 
							if(subject.m_speciality == Subject::COMMUN) 
							{
								for(int spe = 0; spe < Class::s_specialityPerYeer; ++spe)
								{
									classes = {Class::s_class[Class::s_L1Offset+spe*2], Class::s_class[Class::s_L1Offset+spe*2+1]};
									for(float j = 0.f; j < number; j++) 
		        					{ 
		        						//std::cout << "init 2 : " << &subject << std::endl;
		            					list.emplace_back(std::make_tuple(mod, std::ref(subject), classes)); 
		            					//std::cout << "init 3 : " << &list[list.size()-1] << std::endl;
		        					}  
		        				}
		        			}
		        			else
		        			{
	        					classes = {Class::s_class[Class::s_L1Offset+subject.m_speciality*2], Class::s_class[Class::s_L1Offset+subject.m_speciality*2+1]};
								for(float j = 0.f; j < number; j++) 
		        				{ 
		        					//std::cout << "init 2 : " << &subject << std::endl;
		            				list.emplace_back(std::make_tuple(mod, std::ref(subject), classes)); 
		            				//std::cout << "init 3 : " << &list[list.size()-1] << std::endl;
		        				}  
	        				}
						break;
						case Subject::TP : 
							if(subject.m_speciality == Subject::COMMUN) 
							{
								for(int tp = 0; tp < Class::s_L1Count; ++tp)
								{
									classes = {Class::s_class[Class::s_L1Offset+tp]};
									for(float j = 0.f; j < number; j++) 
				        			{ 
				        				//std::cout << "init 2 : " << &subject << std::endl;
				            			list.emplace_back(std::make_tuple(mod, std::ref(subject), classes)); 
				            			//std::cout << "init 3 : " << &list[list.size()-1] << std::endl;
				        			}  
			        			}
		        			}
		        			else
		        			{
		        				classes = {Class::s_class[Class::s_L1Offset+subject.m_speciality*2]};
								for(float j = 0.f; j < number; j++) 
			        			{ 
			        				//std::cout << "init 2 : " << &subject << std::endl;
			            			list.emplace_back(std::make_tuple(mod, std::ref(subject), classes)); 
			            			//std::cout << "init 3 : " << &list[list.size()-1] << std::endl;
			        			}  
			        			classes = {Class::s_class[Class::s_L1Offset+subject.m_speciality*2+1]};
								for(float j = 0.f; j < number; j++) 
			        			{ 
			        				//std::cout << "init 2 : " << &subject << std::endl;
			            			list.emplace_back(std::make_tuple(mod, std::ref(subject), classes)); 
			            			//std::cout << "init 3 : " << &list[list.size()-1] << std::endl;
			        			}  
		        			}	
						break;
						case Subject::MODALITY_SIZE :
						break;
					}
				break;
			} 
		}
	} 

	list = shuffleVector(list);

\end

/* ------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------ */

\After everything else function:
\end

/* ------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------ */

\At the beginning of each generation function:
\endstatic_

/* ------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------ */

\At the end of each generation function:
\end

/* ------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------ */

\At each generation before reduce function:
\end

/* ------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------ */

\User classes :
	GenomeClass { 
		int* m_schedules;	// This is a HACK, it will be changed to void*.
	}
\end

/* ------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------ */

\GenomeClass::display:
\end

/* ------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------ */

\GenomeClass::initialiser:

	Schedules* schedules = new Schedules();

	for(const auto& tuple : shuffleVector(s_MAP))
	{
		Subject::SUBJECT_MODALITY mod = std::get<0>(tuple);
		const Subject& sub = std::get<1>(tuple);
		const std::initializer_list<Class>& classes = std::get<2>(tuple);
		int randWeek = random(0, WEEK_BY_SEMESTER);
		if(sub.m_semester == Subject::S2 || sub.m_semester == Subject::S4)
		{
			randWeek += WEEK_BY_SEMESTER;
		}
		int randDay = random(0, Lesson::DAY_SIZE);
		int randSlot = random(0, Lesson::SLOT_SIZE);

		(*schedules)[randWeek][static_cast<Lesson::LESSON_DAY>(randDay)][static_cast<Lesson::LESSON_SLOT>(randSlot)].emplace_back(Lesson(sub, randTeacher(sub), randRoom(sub, mod), classes));
	}

	//static const std::vector< std::tuple< Subject::SUBJECT_MODALITY, Subject, std::initializer_list<Class> > > s_MAP;
	for(unsigned short _week = 0; _week < WEEK_BY_SEMESTER*2; ++_week)
	{
		for(unsigned short _day = 0; _day < Lesson::DAY_SIZE; ++_day)
		{
			for(unsigned short _slot = 0; _slot < Lesson::SLOT_SIZE; ++_slot)
			{
				std::cout << _week << " " << _day << " " << _slot << "\n\t";
				auto vec = (*schedules)[_week][static_cast<Lesson::LESSON_DAY>(_day)][static_cast<Lesson::LESSON_SLOT>(_slot)];
				for(const Lesson& lesson : vec)
				{
					std::cout << "{" << lesson.m_subject.m_name << " " << &lesson.m_room << " " << lesson.m_teacher << "} "; 
				}
				std::cout << std::endl;
			}
		}
	}

	exit(0);
	Genome.m_schedules = (void*)schedules;
\end

/* ------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------ */

\GenomeClass::crossover:
\end

/* ------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------ */

\GenomeClass::mutator:
  	return 1;
\end

/* ------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------ */

\GenomeClass::evaluator:
	return 1;
\end

/* ------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------ */

\User Makefile options:
	CPPFLAGS += -std=c++11 -g
\end

/* ------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------ */

\Default run parameters :         // Please let the parameters appear in this order
Number of generations : 300       // NB_GEN
Time limit: 0                     // In seconds, 0 to deactivate
Population size : 2           // POP_SIZE
Offspring size : 100%             // 40% 
Mutation probability : 1          // MUT_PROB
Crossover probability : 1         // XOVER_PROB
Evaluator goal : minimise         // Maximise
Selection operator: Tournament 2 
Surviving parents: 100%           // percentage or absolute
Surviving offspring: 100%
Reduce parents operator: Tournament 2
Reduce offspring operator: Tournament 2
Final reduce operator: Tournament 3

Elitism: Weak                     // Weak or Strong
Elite: 1
Print stats: true                 // Default: 1
Generate csv stats file:false
Generate gnuplot script:false
Generate R script:false
Plot stats:true                   // Default: 0

Remote island model: true
IP file: ipexplorer.txt           // File containing all the remote island's IP
Server port : 2929
Migration probability: 0.15       // 0.15 or 0.5

Save population: false
Start from file:false
\end
