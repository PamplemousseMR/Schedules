\User declarations :

#include <vector>
#include <map>
#include <cstdarg>
#include <algorithm>

#include "Teacher.h"
#include "Room.h"
#include "Subject.h"
#include "Class.h"

/* ---------------------------------------------------------------------------------
										Schedules
--------------------------------------------------------------------------------- */

static const unsigned short WEEK_BY_SEMESTER = 14;
static const unsigned short MAX_HOUR_PER_WEEK = 30;
static const unsigned short MAX_HOUR_PER_DAY = 6; 

/* ---------------------------
		Day
--------------------------- */

static const unsigned short DAY_SIZE = 5;

enum DAY
{
	MONDAY,
	TUESDAY,
	WEDNESDAY,
	THURSDAY,
	FRIDAY
};

/* ---------------------------
		Time slots
--------------------------- */

static const float SLOT_INTERVAL = 1.5;

static const unsigned short SLOT_SIZE = 4;

enum SLOT
{
	SLOT_0,
	SLOT_1,
	SLOT_2,
	SLOT_3
};

/* ---------------------------
		Lesson
--------------------------- */

class Lesson
{

public:

	Lesson(const std::string& _ueName, const Teacher& _teacher, const Room& _room,
									std::initializer_list<Class> _classList)
		: 	m_UEname(_ueName),
			m_teacher(_teacher),
			m_room(_room),
			m_class(_classList.begin(), _classList.end())
	{
	}

public:

	const std::string m_UEname;

	const Teacher& m_teacher;

	const Room& m_room;
	
	const std::vector<Class> m_class;

};

/* ---------------------------
		Schedules
--------------------------- */

typedef std::map<SLOT, std::vector<Lesson>> Day;
typedef std::map<DAY, Day> Week;
typedef std::map<int, Week> Schedules; 

\end

\User functions:

bool TeacherBusy(const Day& _day, const SLOT _slot, const Teacher& _teacher)
{
	for(const Lesson& lesson : _day.at(_slot))
	{
		if(&lesson.m_teacher == &_teacher)
		{
			return true;
		}
	}
	return false;
}

bool RoomBusy(const Day& _day, const SLOT _slot, const Room& _room)
{
	for(const Lesson& lesson : _day.at(_slot))
	{
		if(&lesson.m_room == &_room)
		{
			return true;
		}
	}
	return false;
}

bool ClassBusy(const Day& _day, const SLOT _slot, const Class& _class)
{
	for(const Lesson& lesson : _day.at(_slot))
	{
		for(const Class& t_class : lesson.m_class)
		{
			if(&t_class == &_class)
			{
				return true;
			}
		}
	}
	return false;
}

int getRandomSubject(Subject::SUBJECT_SEMESTER _semester, float (*_totalCount)[4])
{
	unsigned short offset = 0;
	unsigned short count = 0;
	switch(_semester)
	{
		case Subject::S1:
			offset = Subject::s_s1Offset;
			count = Subject::s_s1Count;
		break;
		case Subject::S2:
			offset = Subject::s_s2Offset;
			count = Subject::s_s2Count;		
		break;
		case Subject::S3:
			offset = Subject::s_s3Offset;
			count = Subject::s_s3Count;		
		break;
		case Subject::S4:
			offset = Subject::s_s4Offset;
			count = Subject::s_s4Count;
		break;
	}

	std::vector<unsigned> alreadyUsed;
	while(alreadyUsed.size()!=count)
	{
		unsigned rand = random(offset, offset+count);

		if (std::find(alreadyUsed.begin(), alreadyUsed.end(), rand) != alreadyUsed.end())
		{
			continue;
		}
		alreadyUsed.push_back(rand);

		const Subject& result = Subject::s_subjects[rand];
		for (unsigned short _modality = 0; _modality < Subject::SUBJECT_MODALITY_SIZE; _modality++)
		{
			if( result.m_modality.at(static_cast<Subject::SUBJECT_MODALITY>(_modality)) > _totalCount[rand][_modality])
			{
				return rand;
			}
		}
	}
	return -1;
}

Subject::SUBJECT_MODALITY getSubjectFreeType(int _subjectIndex, float (*_totalCount)[4])
{
	const Subject& subject = Subject::s_subjects[_subjectIndex]; 
	while(true)
	{
		unsigned rand = random(0,4);
		if(subject.m_modality.at(static_cast<Subject::SUBJECT_MODALITY>(rand)) > _totalCount[_subjectIndex][rand])
		{
			return static_cast<Subject::SUBJECT_MODALITY>(rand);
		}
	}
}

\end

\User CUDA:
\end

\Before everything else function:
	std::cout << "Teacher list =>" << std::endl;
	for(Teacher _t : Teacher::s_teachers)
	{
		_t.display();
	}
	std::cout << "Room list =>" << std::endl;
	for(Room _r : Room::s_rooms)
	{
		_r.display();
	}
	std::cout << "Class list =>" << std::endl;
	for(Class _c : Class::s_class)
	{
		_c.display();
	}
	std::cout << "Subject list =>" << std::endl;
	for(Subject _s : Subject::s_subjects)
	{
		_s.display();
	}
\end

\After everything else function:
\end

\At the beginning of each generation function:
\end

\At the end of each generation function:
\end

\At each generation before reduce function:
\end

\User classes :
	GenomeClass { 
		int* m_schedules;	// This is a HACK, it will be changed to void*.
	}
\end

\GenomeClass::display:
\end

\GenomeClass::initialiser:
	/*
	typedef std::map<SLOT, std::vector<Lesson>> Day;
	typedef std::map<DAY, Day> Week;
	typedef std::map<int, Week> Schedules;
	*/
	float totalHour[Subject::s_subjects.size()][4];
    #pragma omp parallel for shared(totalHour)
	for(unsigned int i=0 ; i<Subject::s_subjects.size(); ++i)
	{
		for(unsigned int j=0 ; j<4 ; ++j)
		{
			totalHour[i][j] = 0.f;
		}
	}

	Schedules* schedules = new Schedules();

	// First semester
	for(unsigned short _week = 0; _week < WEEK_BY_SEMESTER; ++_week)
	{
		Week week;
		for(unsigned short _day = 0; _day < DAY_SIZE; ++_day)
		{
			Day day;
			for(unsigned short _slot = 0; _slot < SLOT_SIZE; ++_slot)
			{
				int subjectIndex = getRandomSubject(Subject::S1, totalHour);
				if(subjectIndex != -1)
				{
					Subject::SUBJECT_MODALITY modality = getSubjectFreeType(subjectIndex, totalHour);
					totalHour[subjectIndex][modality] += SLOT_INTERVAL;

					//TODO
					std::cout << "{" << _week << " " << _day << " " << _slot << "} "<< subjectIndex << " " << modality << std::endl;
				}
				else
				{

				}
			}
			week[static_cast<DAY>(_day)] = day;
		}
		(*schedules)[_week] = week;
	}

	Genome.m_schedules = (void*)schedules;
\end

\GenomeClass::crossover:
\end

\GenomeClass::mutator:
  	return 1;
\end

\GenomeClass::evaluator:
	return 1;
\end

\User Makefile options:
	CPPFLAGS += -std=c++11
\end

\Default run parameters :         // Please let the parameters appear in this order
Number of generations : 300       // NB_GEN
Time limit: 0                     // In seconds, 0 to deactivate
Population size : 65536           // POP_SIZE
Offspring size : 100%             // 40% 
Mutation probability : 1          // MUT_PROB
Crossover probability : 1         // XOVER_PROB
Evaluator goal : minimise         // Maximise
Selection operator: Tournament 2 
Surviving parents: 100%           // percentage or absolute
Surviving offspring: 100%
Reduce parents operator: Tournament 2
Reduce offspring operator: Tournament 2
Final reduce operator: Tournament 3

Elitism: Weak                     // Weak or Strong
Elite: 1
Print stats: true                 // Default: 1
Generate csv stats file:false
Generate gnuplot script:false
Generate R script:false
Plot stats:true                   // Default: 0

Remote island model: true
IP file: ipexplorer.txt           // File containing all the remote island's IP
Server port : 2929
Migration probability: 0.15       // 0.15 or 0.5

Save population: false
Start from file:false
\end
