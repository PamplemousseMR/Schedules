\User declarations :

#include <vector>
#include <map>
#include <cstdarg>

/* ---------------------------------------------------------------------------------
										Data
--------------------------------------------------------------------------------- */

template <typename T, typename F, typename G>
void variadic_map_emplace(std::map<T,std::map<F,G>>&) {}

template <typename T, typename F, typename G, typename First, typename Second, typename... Args>
void variadic_map_emplace(std::map<T,std::map<F,G>>& v, First&& first, Second&& second, Args&&... args)
{
	v[std::forward<First>(first)][std::forward<Second>(second)] = false;
	variadic_map_emplace(v, std::forward<Args>(args)...);
}

/* ---------------------------
		Day
--------------------------- */

enum DAY
{
	MONDAY,
	TUESDAY,
	WEDNESDAY,
	THURSDAY,
	FRIDAY
};

/* ---------------------------
		Time slots
--------------------------- */

enum SLOT
{
	SLOT_0,
	SLOT_1,
	SLOT_2,
	SLOT_3
};

/* ---------------------------
		Class
--------------------------- */

enum CLASS
{
	L0_SPE_A_1,
	L0_SPE_A_2,
	L0_SPE_B_1,
	L0_SPE_B_2,
	L0_SPE_C_1,
	L0_SPE_C_2,
	L0_SPE_D_1,
	L0_SPE_D_2,
	L1_SPE_A_1,
	L1_SPE_A_2,
	L1_SPE_B_1,
	L1_SPE_B_2,
	L1_SPE_C_1,
	L1_SPE_C_2,
	L1_SPE_D_1,
	L1_SPE_D_2
};

/* ---------------------------
		Teachers
--------------------------- */

class Teacher
{

public:

	static void addTeacher(std::initializer_list<Teacher> _list)
	{
		s_teachers = std::vector<Teacher>(_list.begin(), _list.end());
		for(const Teacher& _teacher : s_teachers)
		{
			std::cout << _teacher << std::endl;
		}
	}

private:

	static std::vector<Teacher> s_teachers;

public:

	enum TEACHERS_TYPE
	{
		MATHS,
		PHYSICS,
		COMPUTER,
		CHEMISTRY,
		ENGLISH,
		FRENCH
	};

	enum TEACHERS_TIME
	{
		FULL,
		HALF,
		HOUR
	};

	template <typename... Args>
	explicit Teacher(TEACHERS_TYPE _type, TEACHERS_TIME _time, const std::string& _name, Args&&... _notAvailable)
		: 	m_type(_type),
			m_time(_time),
			m_name(_name)
	{
		for(int i=0 ; i<5 ; ++i)
		{
			for(int j=0 ; j<4 ; ++j)
			{
				m_availability[(DAY)i][(SLOT)j] = true;
			}
		}
		variadic_map_emplace(m_availability, std::forward<Args>(_notAvailable)...);
	}

	friend ostream& operator<<(ostream& _o, const Teacher& _t)  
	{
		std::string type;
		switch(_t.m_type)
		{
			case MATHS: type = "MATHS"; break;
			case PHYSICS: type = "PHYSICS"; break;
			case COMPUTER: type = "COMPUTER"; break;
			case CHEMISTRY: type = "CHEMISTRY"; break;
			case ENGLISH: type = "ENGLISH"; break;
			case FRENCH: type = "FRENCH"; break;
		}
		std::string time;
		switch(_t.m_time)
		{
			case FULL: time = "FULL"; break;
			case HALF: time = "HALF"; break;
			case HOUR: time = "HOUR"; break;
		}
		_o << "Teacher {" << type << "} : " << _t.m_name << " " << time << " => \n";
		for(int i=0 ; i<5 ; ++i)
		{
			std::string day;
			switch((DAY)i)
			{
				case MONDAY: day = "MONDAY"; break;
				case TUESDAY: day = "TUESDAY"; break;
				case WEDNESDAY: day = "WEDNESDAY"; break;
				case THURSDAY: day = "THURSDAY"; break;
				case FRIDAY: day = "FRIDAY"; break;
			}
			_o << "\t" << day << " :";
			for(int j=0 ; j<4 ; ++j)
			{
				std::string slot;
				switch((SLOT)j)
				{
					case SLOT_0: slot = "8h30-10h00"; break;
					case SLOT_1: slot = "10h15-11h45"; break;
					case SLOT_2: slot = "12h45-14h15"; break;
					case SLOT_3: slot = "14h30-16h00"; break;
				}
				if(!_t.m_availability.at((DAY)i).at((SLOT)j))
				{
					_o << " " << slot << "(false),";
				}
			}
			_o << "\n";
		}
		return _o;
	} 

private:

	const TEACHERS_TYPE m_type;
	const TEACHERS_TIME m_time;
	const std::string m_name;
	std::map<DAY, std::map<SLOT, bool>> m_availability;

};

std::vector<Teacher> Teacher::s_teachers;

/* ---------------------------
		Room
--------------------------- */

class Room
{

public:

	static void addRoom(std::initializer_list<Room> _list)
	{
		s_rooms = std::vector<Room>(_list.begin(), _list.end());
		for(const Room& _room : s_rooms)
		{
			std::cout << _room << std::endl;
		}
	}

private:

	static std::vector<Room> s_rooms;

public:

	enum ROOM_TYPE
	{
		ROOM,
		AMPHI,
		LANGUAGE,
		COMPUTER,
		LABORATORY
	};

	explicit Room(ROOM_TYPE _type, unsigned short _capacity)
		:	m_type(_type),
			m_capacity(_capacity)
	{
	}

    friend ostream& operator<<(ostream& _o, const Room& _r)  
	{
		std::string type;
		switch(_r.m_type)
		{
			case ROOM: type = "ROOM"; break;
			case AMPHI: type = "AMPHI"; break;
			case LANGUAGE: type = "LANGUAGE"; break;
			case COMPUTER: type = "COMPUTER"; break;
			case LABORATORY: type = "LABORATORY"; break;
		}
		_o << "Room {" << type << "} : " << _r.m_capacity;
		return _o;
	} 

private:

	const ROOM_TYPE m_type;
	const unsigned short m_capacity;

};

std::vector<Room> Room::s_rooms;

/* ---------------------------
		Subject
--------------------------- */

class Subject
{

public:
	
	static void addSubject(std::initializer_list<Subject> _list)
	{
		s_subjects = std::vector<Subject>(_list.begin(), _list.end());
		for(const Subject& _subject : s_subjects)
		{
			std::cout << _subject << std::endl;
		}
	}

private:
	
	static std::vector<Subject> s_subjects;

public:
	
	enum SPECIALITY
	{
		COMMUN,
		CHEMICAL,
		COMPUTER,
		GEOPHYSICAL,
		OILNGAS
	};

	enum SEMESTER
	{
		S1,
		S2,
		S3,
		S4
	};

	explicit Subject(const std::string& _name, SEMESTER _semester, SPECIALITY _speciality, unsigned short _cm,
					 unsigned short _ci, unsigned short _td, unsigned short _tp)
		:	m_name(_name),
			m_semester(_semester),
			m_speciality(_speciality),
			m_nbHoursCM(_cm),
			m_nbHoursCI(_ci),
			m_nbHoursTD(_td),
			m_nbHoursTP(_tp)
	{
	}
	
	friend ostream& operator<<(ostream& _o, const Subject& _s)  
	{
		std::string semester;
		switch(_s.m_semester)
		{
			case S1: semester = "S1"; break;
			case S2: semester = "S2"; break;
			case S3: semester = "S3"; break;
			case S4: semester = "S4"; break;
		}
		
		std::string speciality;
		switch(_s.m_speciality)
		{
			case COMMUN: speciality = "COMMUN"; break;
			case CHEMICAL: speciality = "CHEMICAL"; break;
			case COMPUTER: speciality = "COMPUTER"; break;
			case GEOPHYSICAL: speciality = "GEOPHYSICAL"; break;
			case OILNGAS: speciality = "OILNGAS"; break;
		}
		
		_o << "Subject {" << _s.m_name << "  " << semester << " " << speciality << "} =>" ;
		_o << "\n\tCM : " << _s.m_nbHoursCM << "H";
		_o << "\n\tCI : " << _s.m_nbHoursCI << "H";
		_o << "\n\tTD : " << _s.m_nbHoursTD << "H";
		_o << "\n\tTP : " << _s.m_nbHoursTP << "H\n";
		return _o;
	} 

private:
	
	const std::string m_name;
	const SEMESTER m_semester;
	const SPECIALITY m_speciality;
	const unsigned short m_nbHoursCM;
	const unsigned short m_nbHoursCI;
	const unsigned short m_nbHoursTD;
	const unsigned short m_nbHoursTP;

};

std::vector<Subject> Subject::s_subjects;

/* ---------------------------------------------------------------------------------
										Schedules
--------------------------------------------------------------------------------- */

/* ---------------------------
		Lesson
--------------------------- */

class Lesson
{

public:

	Lesson(const std::string& _ueName, const Teacher& _teacher, const Room& _room,
									std::initializer_list<CLASS> _classList)
		: 	m_UEname(_ueName),
			m_teacher(_teacher),
			m_room(_room),
			m_class(_classList.begin(), _classList.end())
	{
	}

private:

	const std::string m_UEname;
	const Teacher& m_teacher;
	const Room& m_room;
	const std::vector<CLASS> m_class;

};

/* ---------------------------
		Schedules
--------------------------- */

typedef std::map<SLOT, std::vector<Lesson>> Day;
typedef std::map<DAY, Day> Week;
typedef std::map<int, Week> Schedules; 

\end

\User functions:

void createTeachers()
{
	std::cout << __FUNCTION__ << "..." << std::endl;
	Teacher::addTeacher({
		Teacher(Teacher::MATHS, Teacher::FULL, "A", MONDAY, SLOT_0, TUESDAY, SLOT_0, WEDNESDAY, SLOT_0, THURSDAY, SLOT_0, FRIDAY, SLOT_0),
		Teacher(Teacher::MATHS, Teacher::FULL, "B", MONDAY, SLOT_2, MONDAY, SLOT_3, TUESDAY, SLOT_2, TUESDAY, SLOT_3, FRIDAY, SLOT_2, FRIDAY, SLOT_3),
		Teacher(Teacher::MATHS, Teacher::FULL, "C", FRIDAY, SLOT_2),

		Teacher(Teacher::PHYSICS, Teacher::FULL, "A", MONDAY, SLOT_0, TUESDAY, SLOT_0, WEDNESDAY, SLOT_0, THURSDAY, SLOT_0, FRIDAY, SLOT_0),
		Teacher(Teacher::PHYSICS, Teacher::FULL, "B", MONDAY, SLOT_2, MONDAY, SLOT_3, TUESDAY, SLOT_2, TUESDAY, SLOT_3, WEDNESDAY, SLOT_2, WEDNESDAY, SLOT_3, THURSDAY, SLOT_2, THURSDAY, SLOT_3, FRIDAY, SLOT_2, FRIDAY, SLOT_3),
		Teacher(Teacher::PHYSICS, Teacher::HALF, "C", MONDAY, SLOT_0, MONDAY, SLOT_1, MONDAY, SLOT_2, MONDAY, SLOT_3, TUESDAY, SLOT_0, TUESDAY, SLOT_1, TUESDAY, SLOT_2, TUESDAY, SLOT_3, WEDNESDAY, SLOT_0, WEDNESDAY, SLOT_1, WEDNESDAY, SLOT_2, WEDNESDAY, SLOT_3, THURSDAY, SLOT_2, THURSDAY, SLOT_3, FRIDAY, SLOT_0, FRIDAY, SLOT_1),
		Teacher(Teacher::PHYSICS, Teacher::HOUR, "D"),

		Teacher(Teacher::COMPUTER, Teacher::FULL, "A"),
		Teacher(Teacher::COMPUTER, Teacher::FULL, "B"),
		Teacher(Teacher::COMPUTER, Teacher::HALF, "C"),
		Teacher(Teacher::COMPUTER, Teacher::HOUR, "D", MONDAY, SLOT_0, MONDAY, SLOT_1, MONDAY, SLOT_2, MONDAY, SLOT_3, FRIDAY, SLOT_0, FRIDAY, SLOT_1, FRIDAY, SLOT_2, FRIDAY, SLOT_3),

		Teacher(Teacher::CHEMISTRY, Teacher::FULL, "A", MONDAY, SLOT_0, TUESDAY, SLOT_0, WEDNESDAY, SLOT_0, THURSDAY, SLOT_0, FRIDAY, SLOT_0),
		Teacher(Teacher::CHEMISTRY, Teacher::FULL, "B"),
		Teacher(Teacher::CHEMISTRY, Teacher::HALF, "C"),
		Teacher(Teacher::CHEMISTRY, Teacher::HALF, "D", MONDAY, SLOT_0, TUESDAY, SLOT_0, WEDNESDAY, SLOT_0, THURSDAY, SLOT_0, FRIDAY, SLOT_0),

		Teacher(Teacher::ENGLISH, Teacher::FULL, "A"),
		Teacher(Teacher::ENGLISH, Teacher::FULL, "B"),
		Teacher(Teacher::ENGLISH, Teacher::HALF, "C"),
		Teacher(Teacher::ENGLISH, Teacher::FULL, "D"),

		Teacher(Teacher::FRENCH, Teacher::FULL, "A"),
		Teacher(Teacher::FRENCH, Teacher::FULL, "B"),
		Teacher(Teacher::FRENCH, Teacher::HALF, "C"),
		Teacher(Teacher::FRENCH, Teacher::HALF, "D"),
		Teacher(Teacher::FRENCH, Teacher::HOUR, "E")
	});
	std::cout << __FUNCTION__ << " done." << std::endl;
}

void createRooms()
{	
	std::cout << __FUNCTION__ << "..." << std::endl;
	Room::addRoom({ 
		Room(Room::AMPHI, 160),
		Room(Room::AMPHI, 160),
	
		Room(Room::ROOM, 40),
		Room(Room::ROOM, 40),
		Room(Room::ROOM, 40),
		Room(Room::ROOM, 40),
		Room(Room::ROOM, 40),
	
		Room(Room::LANGUAGE, 20),
		Room(Room::LANGUAGE, 20),
		Room(Room::LANGUAGE, 20),
		Room(Room::LANGUAGE, 20),
		Room(Room::LANGUAGE, 20),
		Room(Room::LANGUAGE, 20),
		Room(Room::LANGUAGE, 20),
	
		Room(Room::COMPUTER, 20),
		Room(Room::COMPUTER, 20),
	
		Room(Room::LABORATORY, 20),
		Room(Room::LABORATORY, 20)
	});
	std::cout << __FUNCTION__ << " done." << std::endl;
 }

void createSubjects()
{
	std::cout << __FUNCTION__ << "..." << std::endl;
	Subject::addSubject({ 
				Subject("UE101", Subject::S1, Subject::COMMUN, 0, 42, 0, 0),
		Subject("UE102", Subject::S1, Subject::COMMUN, 0, 42, 0, 0),
		Subject("UE103", Subject::S1, Subject::COMMUN, 0, 42, 0, 0),
		Subject("UE104", Subject::S1, Subject::COMMUN, 0, 56, 0, 0),
		Subject("UE105", Subject::S1, Subject::COMMUN, 0, 42, 0, 42),
		Subject("UE106", Subject::S1, Subject::COMMUN, 0, 70, 0, 42),
		Subject("UE107", Subject::S1, Subject::COMMUN, 0, 0, 0, 14),

		Subject("UE201_An", Subject::S2, Subject::COMMUN, 10, 32, 0, 0),
		Subject("UE201_Al", Subject::S2, Subject::COMMUN, 10, 32, 0, 0),
		Subject("UE202", Subject::S2, Subject::COMMUN, 14, 28, 0, 21),
		Subject("UE203", Subject::S2, Subject::COMMUN, 10, 32, 0, 21),
		Subject("UE204", Subject::S2, Subject::COMMUN, 14, 28, 0, 21),
		Subject("UE205", Subject::S2, Subject::COMMUN, 0, 42, 0, 0),
		Subject("UE206", Subject::S2, Subject::COMMUN, 0, 42, 0, 0),
		Subject("UE207", Subject::S2, Subject::COMMUN, 0, 0, 8, 28),

		Subject("UE301", Subject::S3, Subject::COMMUN, 30, 0, 42, 0),
		Subject("UE302_M", Subject::S3, Subject::COMMUN, 21, 0, 21, 0),
		Subject("UE302_T", Subject::S3, Subject::COMMUN, 18, 0, 18, 0),
		Subject("UE302_F", Subject::S3, Subject::COMMUN, 9, 0, 9, 0),
		Subject("UE303", Subject::S3, Subject::COMMUN, 12, 0, 12, 12),
		Subject("UE304_F", Subject::S3, Subject::COMMUN, 0, 36, 0, 0),
		Subject("UE304_E", Subject::S3, Subject::COMMUN, 0, 36, 0, 0),

		Subject("UE305a", Subject::S3, Subject::CHEMICAL, 30, 0, 21, 21),
		Subject("UE306", Subject::S3, Subject::CHEMICAL, 15, 0, 15, 15),

		Subject("UE307", Subject::S3, Subject::COMPUTER, 21, 0, 21, 12),
		Subject("UE308", Subject::S3, Subject::COMPUTER, 15, 0, 0, 21),

		Subject("UE305b", Subject::S3, Subject::GEOPHYSICAL, 30, 0, 21, 21),
		Subject("UE309", Subject::S3, Subject::GEOPHYSICAL, 0, 30, 0, 0),

		Subject("UE305c", Subject::S3, Subject::OILNGAS, 30, 0, 21, 21),
		Subject("UE310", Subject::S3, Subject::OILNGAS, 15, 0, 9, 6),

		Subject("UE401", Subject::S4, Subject::COMMUN, 30, 0, 42, 0),
		Subject("UE402", Subject::S4, Subject::COMMUN, 36, 0, 36, 0),
		Subject("UE403", Subject::S4, Subject::COMMUN, 12, 0, 12, 12),
		Subject("UE404_F", Subject::S4, Subject::COMMUN, 0, 36, 0, 36),
		Subject("UE404_E", Subject::S4, Subject::COMMUN, 0, 36, 0, 36),
		Subject("UE405", Subject::S4, Subject::COMMUN, 6, 6, 0, 6),

		Subject("UE406a", Subject::S4, Subject::CHEMICAL, 30, 0, 30, 21),
		Subject("UE407", Subject::S4, Subject::CHEMICAL, 15, 0, 15, 15),

		Subject("UE408", Subject::S4, Subject::COMPUTER, 21, 0, 21, 12),
		Subject("UE409", Subject::S4, Subject::COMPUTER, 18, 0, 18, 12),

		Subject("UE4062", Subject::S4, Subject::GEOPHYSICAL, 30, 0, 30, 21),
		Subject("UE410", Subject::S4, Subject::GEOPHYSICAL, 0, 30, 0, 0),

		Subject("UE406c", Subject::S4, Subject::OILNGAS, 30, 0, 30, 21),
		Subject("UE411", Subject::S4, Subject::OILNGAS, 15, 0, 6, 9)
	});
	std::cout << __FUNCTION__ << " done." << std::endl;
}

\end

\User CUDA:
\end

\Before everything else function:
	createTeachers();
	createRooms();
	createSubjects();
\end

\After everything else function:
\end

\At the beginning of each generation function:
\end

\At the end of each generation function:
\end

\At each generation before reduce function:
\end

\User classes :
	GenomeClass { 
		float sin[3];
	}
\end

\GenomeClass::display:
\end

\GenomeClass::initialiser :
\end

\GenomeClass::crossover :
\end

\GenomeClass::mutator:
  	return 1;
\end

\GenomeClass::evaluator:
	return 1;
\end

\User Makefile options:
	CPPFLAGS += -std=c++11
\end

\Default run parameters :         // Please let the parameters appear in this order
Number of generations : 300       // NB_GEN
Time limit: 0                     // In seconds, 0 to deactivate
Population size : 65536           // POP_SIZE
Offspring size : 100%             // 40% 
Mutation probability : 1          // MUT_PROB
Crossover probability : 1         // XOVER_PROB
Evaluator goal : minimise         // Maximise
Selection operator: Tournament 2 
Surviving parents: 100%           // percentage or absolute
Surviving offspring: 100%
Reduce parents operator: Tournament 2
Reduce offspring operator: Tournament 2
Final reduce operator: Tournament 3

Elitism: Weak                     // Weak or Strong
Elite: 1
Print stats: true                 // Default: 1
Generate csv stats file:false
Generate gnuplot script:false
Generate R script:false
Plot stats:true                   // Default: 0

Remote island model: true
IP file: ipexplorer.txt           // File containing all the remote island's IP
Server port : 2929
Migration probability: 0.15       // 0.15 or 0.5

Save population: false
Start from file:false
\end
